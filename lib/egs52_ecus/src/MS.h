
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'MS'
*/

#ifndef __ECU_MS_H_
#define __ECU_MS_H_

#include <stdint.h>
    
#define MS_210_CAN_ID 0x0210
#define MS_212_CAN_ID 0x0212
#define MS_268_CAN_ID 0x0268
#define MS_2F3_CAN_ID 0x02F3
#define MS_308_CAN_ID 0x0308
#define MS_312_CAN_ID 0x0312
#define AAD_580_CAN_ID 0x0580
#define MS_608_CAN_ID 0x0608

/** Switching shift MS */
enum class MS_210h_SLV_MS {
	SKL0 = 0, // Shift characteristic "0"
	SKL1 = 1, // Shift characteristic "1"
	SKL2 = 2, // Shift characteristic "2"
	SKL3 = 3, // Shift characteristic "3"
	SKL4 = 4, // Shift characteristic "4"
	SKL5 = 5, // Shift characteristic "5"
	SKL6 = 6, // Shift characteristic "6"
	SKL7 = 7, // Shift characteristic "7"
	SKL8 = 8, // Shift characteristic "8"
	SKL9 = 9, // Shift characteristic "9"
	SKL10 = 10, // Shift characteristic "10"
};

/** Sprocket, upper limit */
enum class MS_210h_GMAX_MS {
	PASSIV = 0, // passive value
	G1 = 1, // Sprocket, upper limit = 1
	G2 = 2, // Sprocket, upper limit = 2
	G3 = 3, // Sprocket, upper limit = 3
	G4 = 4, // Sprocket, upper limit = 4
	G5 = 5, // Sprocket, upper limit = 5
	G6 = 6, // Sprocket, upper limit = 6
	G7 = 7, // Sprocket, upper limit = 7
};

/** Sprocket, lower limit */
enum class MS_210h_GMIN_MS {
	PASSIV = 0, // passive value
	G1 = 1, // Sprocket, lower limit = 1
	G2 = 2, // Sprocket, lower limit = 2
	G3 = 3, // Sprocket, lower limit = 3
	G4 = 4, // Sprocket, lower limit = 4
	G5 = 5, // Sprocket, lower limit = 5
	G6 = 6, // Sprocket, lower limit = 6
	G7 = 7, // Sprocket, lower limit = 7
};

/** Status heating power */
enum class MS_268h_HZL_ST {
	ZU = 0, // Heating shut-off valve is too
	AUF = 1, // Heating shut-off valve is up
	TAKT = 2, // Heating shut-off valve is clocked
	SNV = 3, // signal not available
};

/** Drive Level Switching recommendation "is" */
enum class MS_2F3h_FSC_IST {
	BLANK = 32, // blank ("")
	EINS = 49, // Driving Level "1"
	ZWEI = 50, // Driving Level "2"
	DREI = 51, // Driving Level "3"
	VIER = 52, // Driving Level "4"
	FUENF = 53, // Driving Level "5"
	SECHS = 54, // Driving Level "6"
	SIEBEN = 55, // Driving stage "7"
	A = 65, // Driving stage "A"
	D = 68, // speed "D"
	F = 70, // Error Mark "F"
	N = 78, // Driving "N"
	P = 80, // Driving Level "P"
	R = 82, // Driving "R"
	SNV = 255, // passive value
};

/** Drive Level Switching recommendation "should" */
enum class MS_2F3h_FSC_SOLL {
	HOCH = 1, // "upshift" / arrow
	RUNTER = 2, // "downshift" / arrow
	BLANK/PAS = 32, // blank ("") / passive
	EINS = 49, // Driving Level "1"
	ZWEI = 50, // Driving Level "2"
	DREI = 51, // Driving Level "3"
	VIER = 52, // Driving Level "4"
	FUENF = 53, // Driving Level "5"
	SECHS = 54, // Driving Level "6"
	SIEBEN = 55, // Driving stage "7"
	A = 65, // Driving stage "A"
	D = 68, // speed "D"
	F = 70, // Error Mark "F"
	N = 78, // Driving "N"
	P = 80, // Driving Level "P"
	R = 82, // Driving "R"
	SNV = 255, // passive value
};

/** Vehicle code body */
enum class MS_608h_FCOD_KAR {
	W = 0, // W - Limousine (or G short BM1 / 3 at BR 463, G at 461)
	V = 1, // V - Limousine long (or VF at BR 210/211, G Lang BM6 at BR 463)
	C = 2, // C - CoupÃ© (or VV at BR 210/211/220)
	S = 3, // S - T model (or special protection B4 at BR W240, T at BR 245)
	A = 4, // A - Cabrio (or X at BR 164)
	R = 5, // R - Roadster (or special protection B4 at BR 210 / 211/220 / V240)
	SS = 6, // SS - Special protection B6 / 7 (or CL at BR 203)
	SNV = 7, // Code not available
};

/** Vehicle code series */
enum class MS_608h_FCOD_BR {
	BR221 = 0, // BR 221 Od. BR 140
	BR129 = 1, // BR 129
	BR210 = 2, // BR 210 Od. BR 212
	BR202 = 3, // BR 202 Od. BR 204
	BR220 = 4, // BR 220
	BR170 = 5, // BR 170
	BR203 = 6, // BR 203
	BR168 = 7, // BR 168
	BR163 = 8, // BR 163
	BR208 = 9, // BR 208
	BR463 = 10, // BR 463
	BR215 = 11, // BR 215
	BR230 = 12, // BR 230
	BR211 = 13, // BR 211
	BR209 = 14, // BR 209
	BR461 = 15, // BR 461
	BR240 = 16, // BR 240
	BR251 = 17, // BR 251
	BR171 = 18, // BR 171
	BR164 = 19, // BR 164
	BR169 = 20, // BR 169 Od. BR 245
	BR199 = 21, // BR 199
	BR216 = 22, // BR 216
	BR219 = 23, // BR 219
	BR454 = 24, // BR 454 (Z-CAR)
	NCV2 = 25, // NCV2
	VITO = 26, // V-Class / Vito
	SPRINTER = 27, // Sprinter
	NCV3 = 28, // NCV3
	NCV1 = 29, // NCV1
	REST = 30, // All other BR
	SNV = 31, // Code not available
};

/** FZGCOD.Motor 7Bit, bit0-5 (bit6 -> signal fcod_mot6) */
enum class MS_608h_FCOD_MOT {
	M272E35 = 0, // M272 E35
	M271E18ML105 = 1, // M271 E18 ml Red. (105 kW)
	M271E18ML120 = 2, // M271 E18 ml (120 kW)
	M112E37 = 3, // M112 E37
	M272E25 = 4, // M272 E25
	M272E30 = 5, // M272 E30
	M112E28 = 7, // M112 E28
	M112E32 = 8, // M112 E32
	M273E46 = 10, // M273 E46
	M273E55 = 11, // M273 E55
	M112E26 = 12, // M112 E26
	M113E43 = 13, // M113 E43
	M113E50 = 14, // M113 E50
	M271E18ML140 = 18, // M271 E18 ML / 1 (140 kW)
	M271DE18ML105 = 19, // M271 DE18 ml Red. (105 kW)
	M271DE18ML125 = 20, // M271 DE18 ML (125 kW)
	M111E_E23ML = 22, // M111E E23 ML
	M111E_E20 = 23, // M111E E20
	M111E_E20ML = 24, // M111E E20 ml
	M112E32_140 = 25, // M112 E32 RED. (140 kW)
	M266E20ATL = 26, // M266 E20 ATL
	M266E15 = 27, // M266 E15
	M266E17 = 28, // M266 E17
	M266E20 = 29, // M266 E20
	M275E55 = 30, // M275 E55 Od. M285 E55
	M137E58 = 31, // M137 E58
	OM640DE20LA60 = 32, // OM 640 DE20 LA (60 kW)
	OM640DE20LA80 = 34, // OM 640 DE20 LA (80 kW)
	OM642DE30LA160 = 35, // OM642 DE30 LA (155/160 kW)
	OM640DE20LA100 = 36, // OM 640 DE20 LA (100 kW)
	OM613DE32LA = 37, // OM613 DE32 La od. OM648 DE32 LA
	OM628DE40LA = 39, // OM628 DE40 LA
	OM642DE30LA140 = 40, // OM642 DE30 LA (140 kW)
	OM612DE27LA = 43, // OM612 DE27 LA od. OM647 DE27 LA (120/130 kW)
	OM611DE22LA100 = 44, // OM611 DE22 LA (105/100 kW) Od. OM646 DE22 LA (100/105/110 kW)
	OM611DE22LA85 = 45, // OM611 DE22 LA (85 kW) Od. OM646 DE22 LA (90 kW)
	OM611DE22LA75 = 46, // OM611 DE22 LA (75 kW) Od. OM646 DE22 LA (75 kW)
	M134E11 = 64, // M134 E11 (3A91)
	M135E13 = 65, // M135 E13 (4A90)
	M135E15 = 66, // M135 E15 (4A91)
	M135E15ATL = 67, // M135 E15 ATL
	M272DE25 = 68, // M272 DE25
	M272DE30 = 69, // M272 DE30
	M272DE35 = 70, // M272 DE35
	M273DE46 = 71, // M273 DE46
	M273DE55 = 72, // M273 DE55
	M271E18MLATTR115 = 79, // M271 E18 ml Attr. (115kW)
	M271E18MLATTR141 = 80, // M271 E18 ml Attr. (141kW)
	OM629DE40LA = 96, // OM629 DE40 LA
	OM642DE30LARED140 = 99, // OM642 DE30 LA RED. (140kW)
};

/** Particle filter warning */
enum class MS_608h_PFW {
	OK = 0, // No warning
	PFW1 = 1, // Warning filters too, level 1
	PFW2 = 2, // Warning filters too, level 2
	SNV = 3, // signal not available
};



typedef union {
	uint64_t raw;

	/** Gets CAN ID of MS_210 */
	uint32_t get_canid(){ return MS_210_CAN_ID; }
    /** Sets Climate Compressor Emergency Switch Off */
    void set_KOMP_NOTAUS(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Climate Compressor Emergency Switch Off */
    bool get_KOMP_NOTAUS() { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets Switching shift MS */
    void set_SLV_MS(MS_210h_SLV_MS value){ raw = (raw & 0x87ffffffffffffff) | ((uint64_t)value & 0xf) << 59; }

    /** Gets Switching shift MS */
    MS_210h_SLV_MS get_SLV_MS() { return (MS_210h_SLV_MS)(raw >> 59 & 0xf); }
        
    /** Sets turn off KSG crawl */
    void set_KRIECH_AUS(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets turn off KSG crawl */
    bool get_KRIECH_AUS() { return (bool)(raw >> 57 & 0x1); }
        
    /** Sets MS-WISH: "Attraction 1st gear" */
    void set_ANF1(bool value){ raw = (raw & 0xfeffffffffffffff) | ((uint64_t)value & 0x1) << 56; }

    /** Gets MS-WISH: "Attraction 1st gear" */
    bool get_ANF1() { return (bool)(raw >> 56 & 0x1); }
        
    /** Sets MS request: "Active recirculation" */
    void set_AKT_R_MS(bool value){ raw = (raw & 0xff7fffffffffffff) | ((uint64_t)value & 0x1) << 55; }

    /** Gets MS request: "Active recirculation" */
    bool get_AKT_R_MS() { return (bool)(raw >> 55 & 0x1); }
        
    /** Sets Turn off a heater */
    void set_ZH_AUS_MS(bool value){ raw = (raw & 0xffbfffffffffffff) | ((uint64_t)value & 0x1) << 54; }

    /** Gets Turn off a heater */
    bool get_ZH_AUS_MS() { return (bool)(raw >> 54 & 0x1); }
        
    /** Sets Sprocket, upper limit */
    void set_GMAX_MS(MS_210h_GMAX_MS value){ raw = (raw & 0xffc7ffffffffffff) | ((uint64_t)value & 0x7) << 51; }

    /** Gets Sprocket, upper limit */
    MS_210h_GMAX_MS get_GMAX_MS() { return (MS_210h_GMAX_MS)(raw >> 51 & 0x7); }
        
    /** Sets Sprocket, lower limit */
    void set_GMIN_MS(MS_210h_GMIN_MS value){ raw = (raw & 0xfff8ffffffffffff) | ((uint64_t)value & 0x7) << 48; }

    /** Gets Sprocket, lower limit */
    MS_210h_GMIN_MS get_GMIN_MS() { return (MS_210h_GMIN_MS)(raw >> 48 & 0x7); }
        
    /** Sets pedal value */
    void set_PW(uint8_t value){ raw = (raw & 0xffff00ffffffffff) | ((uint64_t)value & 0xff) << 40; }

    /** Gets pedal value */
    uint8_t get_PW() { return (uint8_t)(raw >> 40 & 0xff); }
        
    /** Sets Minimum display time in the display new trigger */
    void set_V_DSPL_NEU(bool value){ raw = (raw & 0xffffff7fffffffff) | ((uint64_t)value & 0x1) << 39; }

    /** Gets Minimum display time in the display new trigger */
    bool get_V_DSPL_NEU() { return (bool)(raw >> 39 & 0x1); }
        
    /** Sets idle is stable */
    void set_LL_STBL(bool value){ raw = (raw & 0xffffffbfffffffff) | ((uint64_t)value & 0x1) << 38; }

    /** Gets idle is stable */
    bool get_LL_STBL() { return (bool)(raw >> 38 & 0x1); }
        
    /** Sets preheat status */
    void set_VGL_ST(bool value){ raw = (raw & 0xffffffdfffffffff) | ((uint64_t)value & 0x1) << 37; }

    /** Gets preheat status */
    bool get_VGL_ST() { return (bool)(raw >> 37 & 0x1); }
        
    /** Sets Motor Start / Stop plant defective */
    void set_MSS_DEF(bool value){ raw = (raw & 0xffffffefffffffff) | ((uint64_t)value & 0x1) << 36; }

    /** Gets Motor Start / Stop plant defective */
    bool get_MSS_DEF() { return (bool)(raw >> 36 & 0x1); }
        
    /** Sets Motor Start / Stop Plant Control Lamp */
    void set_MSS_KL(bool value){ raw = (raw & 0xfffffff7ffffffff) | ((uint64_t)value & 0x1) << 35; }

    /** Gets Motor Start / Stop Plant Control Lamp */
    bool get_MSS_KL() { return (bool)(raw >> 35 & 0x1); }
        
    /** Sets Motor Start / Stop system active */
    void set_MSS_AKT(bool value){ raw = (raw & 0xfffffffbffffffff) | ((uint64_t)value & 0x1) << 34; }

    /** Gets Motor Start / Stop system active */
    bool get_MSS_AKT() { return (bool)(raw >> 34 & 0x1); }
        
    /** Sets Switch off the climate compressor: acceleration */
    void set_KOMP_BAUS(bool value){ raw = (raw & 0xfffffffdffffffff) | ((uint64_t)value & 0x1) << 33; }

    /** Gets Switch off the climate compressor: acceleration */
    bool get_KOMP_BAUS() { return (bool)(raw >> 33 & 0x1); }
        
    /** Sets CRASH signal from engine control */
    void set_CRASH_MS(bool value){ raw = (raw & 0xfffffffeffffffff) | ((uint64_t)value & 0x1) << 32; }

    /** Gets CRASH signal from engine control */
    bool get_CRASH_MS() { return (bool)(raw >> 32 & 0x1); }
        
    /** Sets Error pedal value transmitter */
    void set_PWG_ERR(bool value){ raw = (raw & 0xffffffff7fffffff) | ((uint64_t)value & 0x1) << 31; }

    /** Gets Error pedal value transmitter */
    bool get_PWG_ERR() { return (bool)(raw >> 31 & 0x1); }
        
    /** Sets idle */
    void set_LL(bool value){ raw = (raw & 0xffffffffbfffffff) | ((uint64_t)value & 0x1) << 30; }

    /** Gets idle */
    bool get_LL() { return (bool)(raw >> 30 & 0x1); }
        
    /** Sets start. Convertible bridging clutch "Slip" */
    void set_KUEB_S_A(bool value){ raw = (raw & 0xffffffffdfffffff) | ((uint64_t)value & 0x1) << 29; }

    /** Gets start. Convertible bridging clutch "Slip" */
    bool get_KUEB_S_A() { return (bool)(raw >> 29 & 0x1); }
        
    /** Sets Tempomat regulates */
    void set_TM_REG(bool value){ raw = (raw & 0xffffffffefffffff) | ((uint64_t)value & 0x1) << 28; }

    /** Gets Tempomat regulates */
    bool get_TM_REG() { return (bool)(raw >> 28 & 0x1); }
        
    /** Sets Speed ââlimit switched on */
    void set_V_MAX_EIN(bool value){ raw = (raw & 0xfffffffff7ffffff) | ((uint64_t)value & 0x1) << 27; }

    /** Gets Speed ââlimit switched on */
    bool get_V_MAX_EIN() { return (bool)(raw >> 27 & 0x1); }
        
    /** Sets Kickdown (conversion scenario open!) */
    void set_KD_MS(bool value){ raw = (raw & 0xfffffffffbffffff) | ((uint64_t)value & 0x1) << 26; }

    /** Gets Kickdown (conversion scenario open!) */
    bool get_KD_MS() { return (bool)(raw >> 26 & 0x1); }
        
    /** Sets emergency operation */
    void set_NOTL(bool value){ raw = (raw & 0xfffffffffdffffff) | ((uint64_t)value & 0x1) << 25; }

    /** Gets emergency operation */
    bool get_NOTL() { return (bool)(raw >> 25 & 0x1); }
        
    /** Sets Warning Number */
    void set_V_MAX_SUM(bool value){ raw = (raw & 0xfffffffffeffffff) | ((uint64_t)value & 0x1) << 24; }

    /** Gets Warning Number */
    bool get_V_MAX_SUM() { return (bool)(raw >> 24 & 0x1); }
        
    /** Sets FBStart Error */
    void set_FBS_SE(bool value){ raw = (raw & 0xffffffffff7fffff) | ((uint64_t)value & 0x1) << 23; }

    /** Gets FBStart Error */
    bool get_FBS_SE() { return (bool)(raw >> 23 & 0x1); }
        
    /** Sets Display "Winter tire limitation achieved" on the display */
    void set_V_DSPL_PGB(bool value){ raw = (raw & 0xffffffffffbfffff) | ((uint64_t)value & 0x1) << 22; }

    /** Gets Display "Winter tire limitation achieved" on the display */
    bool get_V_DSPL_PGB() { return (bool)(raw >> 22 & 0x1); }
        
    /** Sets Tempomat turned on */
    void set_TM_EIN(bool value){ raw = (raw & 0xffffffffffdfffff) | ((uint64_t)value & 0x1) << 21; }

    /** Gets Tempomat turned on */
    bool get_TM_EIN() { return (bool)(raw >> 21 & 0x1); }
        
    /** Sets Speed ââlimiter regulates */
    void set_V_MAX_REG(bool value){ raw = (raw & 0xffffffffffefffff) | ((uint64_t)value & 0x1) << 20; }

    /** Gets Speed ââlimiter regulates */
    bool get_V_MAX_REG() { return (bool)(raw >> 20 & 0x1); }
        
    /** Sets Display "Limit?" on the display */
    void set_V_DSPL_LIM(bool value){ raw = (raw & 0xfffffffffff7ffff) | ((uint64_t)value & 0x1) << 19; }

    /** Gets Display "Limit?" on the display */
    bool get_V_DSPL_LIM() { return (bool)(raw >> 19 & 0x1); }
        
    /** Sets Display "Error" on the display */
    void set_V_DSPL_ERR(bool value){ raw = (raw & 0xfffffffffffbffff) | ((uint64_t)value & 0x1) << 18; }

    /** Gets Display "Error" on the display */
    bool get_V_DSPL_ERR() { return (bool)(raw >> 18 & 0x1); }
        
    /** Sets Display flashes */
    void set_V_DSPL_BL(bool value){ raw = (raw & 0xfffffffffffdffff) | ((uint64_t)value & 0x1) << 17; }

    /** Gets Display flashes */
    bool get_V_DSPL_BL() { return (bool)(raw >> 17 & 0x1); }
        
    /** Sets Surrupy / Tempomat display */
    void set_V_DSPL_EIN(bool value){ raw = (raw & 0xfffffffffffeffff) | ((uint64_t)value & 0x1) << 16; }

    /** Gets Surrupy / Tempomat display */
    bool get_V_DSPL_EIN() { return (bool)(raw >> 16 & 0x1); }
        
    /** Sets factor for departure. d. Max. Mom. At Aufneh. A.Print */
    void set_FMMOTMAX(uint8_t value){ raw = (raw & 0xffffffffffff00ff) | ((uint64_t)value & 0xff) << 8; }

    /** Gets factor for departure. d. Max. Mom. At Aufneh. A.Print */
    uint8_t get_FMMOTMAX() { return (uint8_t)(raw >> 8 & 0xff); }
        
    /** Sets Set maximum or cruise speed */
    void set_V_MAX_TM(uint8_t value){ raw = (raw & 0xffffffffffffff00) | ((uint64_t)value & 0xff) << 0; }

    /** Gets Set maximum or cruise speed */
    uint8_t get_V_MAX_TM() { return (uint8_t)(raw >> 0 & 0xff); }
        
} MS_210;



typedef union {
	uint64_t raw;

	/** Gets CAN ID of MS_212 */
	uint32_t get_canid(){ return MS_212_CAN_ID; }
    /** Sets Motorley roll speed */
    void set_NMOTS(uint16_t value){ raw = (raw & 0x0000ffffffffffff) | ((uint64_t)value & 0xffff) << 48; }

    /** Gets Motorley roll speed */
    uint16_t get_NMOTS() { return (uint16_t)(raw >> 48 & 0xffff); }
        
    /** Sets Serial mpomat is variant encoded */
    void set_TM_MS(bool value){ raw = (raw & 0xffffbfffffffffff) | ((uint64_t)value & 0x1) << 46; }

    /** Gets Serial mpomat is variant encoded */
    bool get_TM_MS() { return (bool)(raw >> 46 & 0x1); }
        
    /** Sets Enable torque requirement type */
    void set_M_ART_E(bool value){ raw = (raw & 0xffffdfffffffffff) | ((uint64_t)value & 0x1) << 45; }

    /** Gets Enable torque requirement type */
    bool get_M_ART_E() { return (bool)(raw >> 45 & 0x1); }
        
    /** Sets default torque driver */
    void set_M_FV(uint16_t value){ raw = (raw & 0xffffe000ffffffff) | ((uint64_t)value & 0x1fff) << 32; }

    /** Gets default torque driver */
    uint16_t get_M_FV() { return (uint16_t)(raw >> 32 & 0x1fff); }
        
    /** Sets ENABLE Fast torque setting */
    void set_SME_E(bool value){ raw = (raw & 0xffffffffbfffffff) | ((uint64_t)value & 0x1) << 30; }

    /** Gets ENABLE Fast torque setting */
    bool get_SME_E() { return (bool)(raw >> 30 & 0x1); }
        
    /** Sets Enable torque requirement ESP */
    void set_M_ESP_E(bool value){ raw = (raw & 0xffffffffdfffffff) | ((uint64_t)value & 0x1) << 29; }

    /** Gets Enable torque requirement ESP */
    bool get_M_ESP_E() { return (bool)(raw >> 29 & 0x1); }
        
    /** Sets replacement feed torque driver */
    void set_M_FEV(uint16_t value){ raw = (raw & 0xffffffffe000ffff) | ((uint64_t)value & 0x1fff) << 16; }

    /** Gets replacement feed torque driver */
    uint16_t get_M_FEV() { return (uint16_t)(raw >> 16 & 0x1fff); }
        
    /** Sets Transfer Calid / CVN Enable */
    void set_CALID_CVN_E(bool value){ raw = (raw & 0xffffffffffff7fff) | ((uint64_t)value & 0x1) << 15; }

    /** Gets Transfer Calid / CVN Enable */
    bool get_CALID_CVN_E() { return (bool)(raw >> 15 & 0x1); }
        
    /** Sets acknowledgment torque requirement EGS */
    void set_M_EGS_Q(bool value){ raw = (raw & 0xffffffffffffbfff) | ((uint64_t)value & 0x1) << 14; }

    /** Gets acknowledgment torque requirement EGS */
    bool get_M_EGS_Q() { return (bool)(raw >> 14 & 0x1); }
        
    /** Sets Enable torque requirement EGS */
    void set_M_EGS_E(bool value){ raw = (raw & 0xffffffffffffdfff) | ((uint64_t)value & 0x1) << 13; }

    /** Gets Enable torque requirement EGS */
    bool get_M_EGS_E() { return (bool)(raw >> 13 & 0x1); }
        
    /** Sets default torque ESP */
    void set_M_ESPV(uint16_t value){ raw = (raw & 0xffffffffffffe000) | ((uint64_t)value & 0x1fff) << 0; }

    /** Gets default torque ESP */
    uint16_t get_M_ESPV() { return (uint16_t)(raw >> 0 & 0x1fff); }
        
} MS_212;



typedef union {
	uint64_t raw;

	/** Gets CAN ID of MS_268 */
	uint32_t get_canid(){ return MS_268_CAN_ID; }
    /** Sets target translation, lower border (FCVT) */
    void set_IMIN_MS(uint8_t value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets target translation, lower border (FCVT) */
    uint8_t get_IMIN_MS() { return (uint8_t)(raw >> 56 & 0xff); }
        
    /** Sets Target Translation, Upper Border (FCVT) */
    void set_IMAX_MS(uint8_t value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets Target Translation, Upper Border (FCVT) */
    uint8_t get_IMAX_MS() { return (uint8_t)(raw >> 48 & 0xff); }
        
    /** Sets Terminal 61 */
    void set_KL_61_EIN(bool value){ raw = (raw & 0xffff7fffffffffff) | ((uint64_t)value & 0x1) << 47; }

    /** Gets Terminal 61 */
    bool get_KL_61_EIN() { return (bool)(raw >> 47 & 0x1); }
        
    /** Sets Oil Info, reserved M266 */
    void set_OEL_INFO_169(bool value){ raw = (raw & 0xffffbfffffffffff) | ((uint64_t)value & 0x1) << 46; }

    /** Gets Oil Info, reserved M266 */
    bool get_OEL_INFO_169() { return (bool)(raw >> 46 & 0x1); }
        
    /** Sets shut-off valve cooling circuit M266 ATL */
    void set_ASV_KKL_169(bool value){ raw = (raw & 0xffffdfffffffffff) | ((uint64_t)value & 0x1) << 45; }

    /** Gets shut-off valve cooling circuit M266 ATL */
    bool get_ASV_KKL_169() { return (bool)(raw >> 45 & 0x1); }
        
    /** Sets Status heating power */
    void set_HZL_ST(MS_268h_HZL_ST value){ raw = (raw & 0xfffffcffffffffff) | ((uint64_t)value & 0x3) << 40; }

    /** Gets Status heating power */
    MS_268h_HZL_ST get_HZL_ST() { return (MS_268h_HZL_ST)(raw >> 40 & 0x3); }
        
    /** Sets Request for power-free in "D" (FCVT) */
    void set_KID_MS(bool value){ raw = (raw & 0xffffff7fffffffff) | ((uint64_t)value & 0x1) << 39; }

    /** Gets Request for power-free in "D" (FCVT) */
    bool get_KID_MS() { return (bool)(raw >> 39 & 0x1); }
        
    /** Sets Mode air control system */
    void set_LRS_MODE(bool value){ raw = (raw & 0xffffffbfffffffff) | ((uint64_t)value & 0x1) << 38; }

    /** Gets Mode air control system */
    bool get_LRS_MODE() { return (bool)(raw >> 38 & 0x1); }
        
    /** Sets Generator utilization (LIN generators only!) */
    void set_LAST_GEN(uint8_t value){ raw = (raw & 0xffffffc0ffffffff) | ((uint64_t)value & 0x3f) << 32; }

    /** Gets Generator utilization (LIN generators only!) */
    uint8_t get_LAST_GEN() { return (uint8_t)(raw >> 32 & 0x3f); }
        
    /** Sets Max. Climate compressor torque */
    void set_M_KOMP_MAX(uint8_t value){ raw = (raw & 0xffffffff00ffffff) | ((uint64_t)value & 0xff) << 24; }

    /** Gets Max. Climate compressor torque */
    uint8_t get_M_KOMP_MAX() { return (uint8_t)(raw >> 24 & 0xff); }
        
    /** Sets pedal value driver (only 169) */
    void set_PW_F(uint8_t value){ raw = (raw & 0xffffffffff00ffff) | ((uint64_t)value & 0xff) << 16; }

    /** Gets pedal value driver (only 169) */
    uint8_t get_PW_F() { return (uint8_t)(raw >> 16 & 0xff); }
        
} MS_268;



typedef union {
	uint64_t raw;

	/** Gets CAN ID of MS_2F3 */
	uint32_t get_canid(){ return MS_2F3_CAN_ID; }
    /** Sets Drive Level Switching recommendation "is" */
    void set_FSC_IST(MS_2F3h_FSC_IST value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets Drive Level Switching recommendation "is" */
    MS_2F3h_FSC_IST get_FSC_IST() { return (MS_2F3h_FSC_IST)(raw >> 56 & 0xff); }
        
    /** Sets Drive Level Switching recommendation "should" */
    void set_FSC_SOLL(MS_2F3h_FSC_SOLL value){ raw = (raw & 0xffffffffff00ffff) | ((uint64_t)value & 0xff) << 16; }

    /** Gets Drive Level Switching recommendation "should" */
    MS_2F3h_FSC_SOLL get_FSC_SOLL() { return (MS_2F3h_FSC_SOLL)(raw >> 16 & 0xff); }
        
} MS_2F3;



typedef union {
	uint64_t raw;

	/** Gets CAN ID of MS_308 */
	uint32_t get_canid(){ return MS_308_CAN_ID; }
    /** Sets clutch kicked */
    void set_KPL(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets clutch kicked */
    bool get_KPL() { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets start.Convertible bridging clutch "Open" */
    void set_KUEB_O_A(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets start.Convertible bridging clutch "Open" */
    bool get_KUEB_O_A() { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets Speed limiting function active */
    void set_N_MAX_BG(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Speed limiting function active */
    bool get_N_MAX_BG() { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets Partinal shutdown */
    void set_SAST(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets Partinal shutdown */
    bool get_SAST() { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets push shutdown full */
    void set_SASV(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets push shutdown full */
    bool get_SASV() { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets Fuel filter clogs control lamp (CR2 US only) */
    void set_KSF_KL(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets Fuel filter clogs control lamp (CR2 US only) */
    bool get_KSF_KL() { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets Water in the fuel control lamp (CR2 US only) */
    void set_WKS_KL(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets Water in the fuel control lamp (CR2 US only) */
    bool get_WKS_KL() { return (bool)(raw >> 57 & 0x1); }
        
    /** Sets Cylinder shutdown conditions fulfilled */
    void set_ZASBED(bool value){ raw = (raw & 0xfeffffffffffffff) | ((uint64_t)value & 0x1) << 56; }

    /** Gets Cylinder shutdown conditions fulfilled */
    bool get_ZASBED() { return (bool)(raw >> 56 & 0x1); }
        
    /** Sets engine speed */
    void set_NMOT(uint16_t value){ raw = (raw & 0xff0000ffffffffff) | ((uint64_t)value & 0xffff) << 40; }

    /** Gets engine speed */
    uint16_t get_NMOT() { return (uint16_t)(raw >> 40 & 0xffff); }
        
    /** Sets Warning message ECO steering helping pump */
    void set_ELHP_WARN(bool value){ raw = (raw & 0xffffffbfffffffff) | ((uint64_t)value & 0x1) << 38; }

    /** Gets Warning message ECO steering helping pump */
    bool get_ELHP_WARN() { return (bool)(raw >> 38 & 0x1); }
        
    /** Sets Ethanol operation detected */
    void set_EOH(bool value){ raw = (raw & 0xffffffdfffffffff) | ((uint64_t)value & 0x1) << 37; }

    /** Gets Ethanol operation detected */
    bool get_EOH() { return (bool)(raw >> 37 & 0x1); }
        
    /** Sets Air filter dirty warning lamp (only diesel) */
    void set_LUFI_KL(bool value){ raw = (raw & 0xffffffefffffffff) | ((uint64_t)value & 0x1) << 36; }

    /** Gets Air filter dirty warning lamp (only diesel) */
    bool get_LUFI_KL() { return (bool)(raw >> 36 & 0x1); }
        
    /** Sets pre-glow control lamp */
    void set_VGL_KL(bool value){ raw = (raw & 0xfffffff7ffffffff) | ((uint64_t)value & 0x1) << 35; }

    /** Gets pre-glow control lamp */
    bool get_VGL_KL() { return (bool)(raw >> 35 & 0x1); }
        
    /** Sets oil level / oil pressure control lamp */
    void set_OEL_KL(bool value){ raw = (raw & 0xfffffffbffffffff) | ((uint64_t)value & 0x1) << 34; }

    /** Gets oil level / oil pressure control lamp */
    bool get_OEL_KL() { return (bool)(raw >> 34 & 0x1); }
        
    /** Sets Diagnosis Control Lamp (OBD II) */
    void set_DIAG_KL(bool value){ raw = (raw & 0xfffffffdffffffff) | ((uint64_t)value & 0x1) << 33; }

    /** Gets Diagnosis Control Lamp (OBD II) */
    bool get_DIAG_KL() { return (bool)(raw >> 33 & 0x1); }
        
    /** Sets Tank lid open check lamp */
    void set_TANK_KL(bool value){ raw = (raw & 0xfffffffeffffffff) | ((uint64_t)value & 0x1) << 32; }

    /** Gets Tank lid open check lamp */
    bool get_TANK_KL() { return (bool)(raw >> 32 & 0x1); }
        
    /** Sets Engine oil temperature too high (overheating) */
    void set_UEHITZ(bool value){ raw = (raw & 0xffffffff7fffffff) | ((uint64_t)value & 0x1) << 31; }

    /** Gets Engine oil temperature too high (overheating) */
    bool get_UEHITZ() { return (bool)(raw >> 31 & 0x1); }
        
    /** Sets Cylinder shutdown */
    void set_ZAS(bool value){ raw = (raw & 0xffffffffbfffffff) | ((uint64_t)value & 0x1) << 30; }

    /** Gets Cylinder shutdown */
    bool get_ZAS() { return (bool)(raw >> 30 & 0x1); }
        
    /** Sets ADR check lamp (NFZ only) */
    void set_ADR_KL(bool value){ raw = (raw & 0xffffffffdfffffff) | ((uint64_t)value & 0x1) << 29; }

    /** Gets ADR check lamp (NFZ only) */
    bool get_ADR_KL() { return (bool)(raw >> 29 & 0x1); }
        
    /** Sets ADR defective control lamp (NFZ only) */
    void set_ADR_DEF_KL(bool value){ raw = (raw & 0xffffffffefffffff) | ((uint64_t)value & 0x1) << 28; }

    /** Gets ADR defective control lamp (NFZ only) */
    bool get_ADR_DEF_KL() { return (bool)(raw >> 28 & 0x1); }
        
    /** Sets starter is running */
    void set_ANL_LFT(bool value){ raw = (raw & 0xfffffffff7ffffff) | ((uint64_t)value & 0x1) << 27; }

    /** Gets starter is running */
    bool get_ANL_LFT() { return (bool)(raw >> 27 & 0x1); }
        
    /** Sets Motor Heater Defective Control Lamp */
    void set_LUEFT_MOT_KL(bool value){ raw = (raw & 0xfffffffffbffffff) | ((uint64_t)value & 0x1) << 26; }

    /** Gets Motor Heater Defective Control Lamp */
    bool get_LUEFT_MOT_KL() { return (bool)(raw >> 26 & 0x1); }
        
    /** Sets Speed limitation for display active (0 at CR) */
    void set_DBAA(bool value){ raw = (raw & 0xfffffffffdffffff) | ((uint64_t)value & 0x1) << 25; }

    /** Gets Speed limitation for display active (0 at CR) */
    bool get_DBAA() { return (bool)(raw >> 25 & 0x1); }
        
    /** Sets cooling water temperature too high */
    void set_TEMP_KL(bool value){ raw = (raw & 0xfffffffffeffffff) | ((uint64_t)value & 0x1) << 24; }

    /** Gets cooling water temperature too high */
    bool get_TEMP_KL() { return (bool)(raw >> 24 & 0x1); }
        
    /** Sets Oil temperature */
    void set_T_OEL(uint8_t value){ raw = (raw & 0xffffffffff00ffff) | ((uint64_t)value & 0xff) << 16; }

    /** Gets Oil temperature */
    uint8_t get_T_OEL() { return (uint8_t)(raw >> 16 & 0xff); }
        
    /** Sets oil level */
    void set_OEL_FS(uint8_t value){ raw = (raw & 0xffffffffffff00ff) | ((uint64_t)value & 0xff) << 8; }

    /** Gets oil level */
    uint8_t get_OEL_FS() { return (uint8_t)(raw >> 8 & 0xff); }
        
    /** Sets oil quality */
    void set_OEL_QUAL(uint8_t value){ raw = (raw & 0xffffffffffffff00) | ((uint64_t)value & 0xff) << 0; }

    /** Gets oil quality */
    uint8_t get_OEL_QUAL() { return (uint8_t)(raw >> 0 & 0xff); }
        
} MS_308;



typedef union {
	uint64_t raw;

	/** Gets CAN ID of MS_312 */
	uint32_t get_canid(){ return MS_312_CAN_ID; }
    /** Sets Motor torque static */
    void set_M_STA(uint16_t value){ raw = (raw & 0xe000ffffffffffff) | ((uint64_t)value & 0x1fff) << 48; }

    /** Gets Motor torque static */
    uint16_t get_M_STA() { return (uint16_t)(raw >> 48 & 0x1fff); }
        
    /** Sets Motor Torque Maximum incl. DYN.Turbocharger */
    void set_M_MAX_ATL(uint16_t value){ raw = (raw & 0xffffe000ffffffff) | ((uint64_t)value & 0x1fff) << 32; }

    /** Gets Motor Torque Maximum incl. DYN.Turbocharger */
    uint16_t get_M_MAX_ATL() { return (uint16_t)(raw >> 32 & 0x1fff); }
        
    /** Sets Motor torque maximum */
    void set_M_MAX(uint16_t value){ raw = (raw & 0xffffffffe000ffff) | ((uint64_t)value & 0x1fff) << 16; }

    /** Gets Motor torque maximum */
    uint16_t get_M_MAX() { return (uint16_t)(raw >> 16 & 0x1fff); }
        
    /** Sets Motor torque minimal */
    void set_M_MIN(uint16_t value){ raw = (raw & 0xffffffffffffe000) | ((uint64_t)value & 0x1fff) << 0; }

    /** Gets Motor torque minimal */
    uint16_t get_M_MIN() { return (uint16_t)(raw >> 0 & 0x1fff); }
        
} MS_312;



typedef union {
	uint64_t raw;

	/** Gets CAN ID of AAD_580 */
	uint32_t get_canid(){ return AAD_580_CAN_ID; }
    /** Sets indicator acceleration type (> 100: dynamic) */
    void set_FTK_BMI(uint8_t value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets indicator acceleration type (> 100: dynamic) */
    uint8_t get_FTK_BMI() { return (uint8_t)(raw >> 56 & 0xff); }
        
    /** Sets Code of the transverse acceleration type (> 100: dynamic) */
    void set_FTK_LMI(uint8_t value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets Code of the transverse acceleration type (> 100: dynamic) */
    uint8_t get_FTK_LMI() { return (uint8_t)(raw >> 48 & 0xff); }
        
    /** Sets code number brake type (> 100: dynamic) */
    void set_FTK_VMI(uint8_t value){ raw = (raw & 0xffff00ffffffffff) | ((uint64_t)value & 0xff) << 40; }

    /** Gets code number brake type (> 100: dynamic) */
    uint8_t get_FTK_VMI() { return (uint8_t)(raw >> 40 & 0xff); }
        
    /** Sets Max. Diff.Pedal angle value per maneuver */
    void set_FTK_DPW(uint8_t value){ raw = (raw & 0xffffffff00ffffff) | ((uint64_t)value & 0xff) << 24; }

    /** Gets Max. Diff.Pedal angle value per maneuver */
    uint8_t get_FTK_DPW() { return (uint8_t)(raw >> 24 & 0xff); }
        
    /** Sets Continuous driver watching */
    void set_AADKB(uint8_t value){ raw = (raw & 0xffffffffff00ffff) | ((uint64_t)value & 0xff) << 16; }

    /** Gets Continuous driver watching */
    uint8_t get_AADKB() { return (uint8_t)(raw >> 16 & 0xff); }
        
    /** Sets Spontaneous dynamic requirement */
    void set_AADKBDYN(bool value){ raw = (raw & 0xffffffffffff7fff) | ((uint64_t)value & 0x1) << 15; }

    /** Gets Spontaneous dynamic requirement */
    bool get_AADKBDYN() { return (bool)(raw >> 15 & 0x1); }
        
    /** Sets nervousness */
    void set_AADNT(uint8_t value){ raw = (raw & 0xffffffffffffff00) | ((uint64_t)value & 0xff) << 0; }

    /** Gets nervousness */
    uint8_t get_AADNT() { return (uint8_t)(raw >> 0 & 0xff); }
        
} AAD_580;



typedef union {
	uint64_t raw;

	/** Gets CAN ID of MS_608 */
	uint32_t get_canid(){ return MS_608_CAN_ID; }
    /** Sets engine coolant temperature */
    void set_T_MOT(uint8_t value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets engine coolant temperature */
    uint8_t get_T_MOT() { return (uint8_t)(raw >> 56 & 0xff); }
        
    /** Sets intake air temperature */
    void set_T_LUFT(uint8_t value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets intake air temperature */
    uint8_t get_T_LUFT() { return (uint8_t)(raw >> 48 & 0xff); }
        
    /** Sets Vehicle code body */
    void set_FCOD_KAR(MS_608h_FCOD_KAR value){ raw = (raw & 0xffff1fffffffffff) | ((uint64_t)value & 0x7) << 45; }

    /** Gets Vehicle code body */
    MS_608h_FCOD_KAR get_FCOD_KAR() { return (MS_608h_FCOD_KAR)(raw >> 45 & 0x7); }
        
    /** Sets Vehicle code series */
    void set_FCOD_BR(MS_608h_FCOD_BR value){ raw = (raw & 0xffffe0ffffffffff) | ((uint64_t)value & 0x1f) << 40; }

    /** Gets Vehicle code series */
    MS_608h_FCOD_BR get_FCOD_BR() { return (MS_608h_FCOD_BR)(raw >> 40 & 0x1f); }
        
    /** Sets Vehicle code engine with 7 bit, bit 6 */
    void set_FCOD_MOT6(bool value){ raw = (raw & 0xffffff7fffffffff) | ((uint64_t)value & 0x1) << 39; }

    /** Gets Vehicle code engine with 7 bit, bit 6 */
    bool get_FCOD_MOT6() { return (bool)(raw >> 39 & 0x1); }
        
    /** Sets Transmission control not available */
    void set_GS_NVH(bool value){ raw = (raw & 0xffffffbfffffffff) | ((uint64_t)value & 0x1) << 38; }

    /** Gets Transmission control not available */
    bool get_GS_NVH() { return (bool)(raw >> 38 & 0x1); }
        
    /** Sets FZGCOD.Motor 7Bit, bit0-5 (bit6 -> signal fcod_mot6) */
    void set_FCOD_MOT(MS_608h_FCOD_MOT value){ raw = (raw & 0xffffffc0ffffffff) | ((uint64_t)value & 0x3f) << 32; }

    /** Gets FZGCOD.Motor 7Bit, bit0-5 (bit6 -> signal fcod_mot6) */
    MS_608h_FCOD_MOT get_FCOD_MOT() { return (MS_608h_FCOD_MOT)(raw >> 32 & 0x3f); }
        
    /** Sets Fixed maximum speed */
    void set_V_MAX_FIX(uint8_t value){ raw = (raw & 0xffffffff00ffffff) | ((uint64_t)value & 0xff) << 24; }

    /** Gets Fixed maximum speed */
    uint8_t get_V_MAX_FIX() { return (uint8_t)(raw >> 24 & 0xff); }
        
    /** Sets consumption */
    void set_VB(uint16_t value){ raw = (raw & 0xffffffffff0000ff) | ((uint64_t)value & 0xffff) << 8; }

    /** Gets consumption */
    uint16_t get_VB() { return (uint16_t)(raw >> 8 & 0xffff); }
        
    /** Sets Turn on auxiliary water pump */
    void set_ZWP_EIN_MS(bool value){ raw = (raw & 0xffffffffffffff7f) | ((uint64_t)value & 0x1) << 7; }

    /** Gets Turn on auxiliary water pump */
    bool get_ZWP_EIN_MS() { return (bool)(raw >> 7 & 0x1); }
        
    /** Sets Particle filter warning */
    void set_PFW(MS_608h_PFW value){ raw = (raw & 0xffffffffffffff9f) | ((uint64_t)value & 0x3) << 5; }

    /** Gets Particle filter warning */
    MS_608h_PFW get_PFW() { return (MS_608h_PFW)(raw >> 5 & 0x3); }
        
    /** Sets Switch on additional consumers */
    void set_ZVB_EIN_MS(bool value){ raw = (raw & 0xffffffffffffffef) | ((uint64_t)value & 0x1) << 4; }

    /** Gets Switch on additional consumers */
    bool get_ZVB_EIN_MS() { return (bool)(raw >> 4 & 0x1); }
        
    /** Sets Particle Filter Correction Offset FMMOTMAX */
    void set_PFKO(uint8_t value){ raw = (raw & 0xfffffffffffffff0) | ((uint64_t)value & 0xf) << 0; }

    /** Gets Particle Filter Correction Offset FMMOTMAX */
    uint8_t get_PFKO() { return (uint8_t)(raw >> 0 & 0xf); }
        
} MS_608;



class ECU_MS {
	public:
        /**
         * @brief Imports the CAN frame given the CAN ID, CAN Contents, and current timestamp
         *
         * Returns true if the frame was imported successfully, and false if import failed (Due to non-matching CAN ID).
         *
         * NOTE: The endianness of the value cannot be guaranteed. It is up to the caller to correct the byte order!
         */
        bool import_frames(uint64_t value, uint32_t can_id, uint64_t timestamp_now) {
            switch(can_id) {
                case MS_210_CAN_ID:
                    LAST_FRAME_TIMES[0] = timestamp_now;
                    FRAME_DATA[0] = value;
                    return true;
                case MS_212_CAN_ID:
                    LAST_FRAME_TIMES[1] = timestamp_now;
                    FRAME_DATA[1] = value;
                    return true;
                case MS_268_CAN_ID:
                    LAST_FRAME_TIMES[2] = timestamp_now;
                    FRAME_DATA[2] = value;
                    return true;
                case MS_2F3_CAN_ID:
                    LAST_FRAME_TIMES[3] = timestamp_now;
                    FRAME_DATA[3] = value;
                    return true;
                case MS_308_CAN_ID:
                    LAST_FRAME_TIMES[4] = timestamp_now;
                    FRAME_DATA[4] = value;
                    return true;
                case MS_312_CAN_ID:
                    LAST_FRAME_TIMES[5] = timestamp_now;
                    FRAME_DATA[5] = value;
                    return true;
                case AAD_580_CAN_ID:
                    LAST_FRAME_TIMES[6] = timestamp_now;
                    FRAME_DATA[6] = value;
                    return true;
                case MS_608_CAN_ID:
                    LAST_FRAME_TIMES[7] = timestamp_now;
                    FRAME_DATA[7] = value;
                    return true;
                default:
                    return false;
            }
        }
        
        /** Sets data in pointer to MS_210
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_210(uint64_t now, uint64_t max_expire_time, MS_210* dest) {
            if (LAST_FRAME_TIMES[0] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (LAST_FRAME_TIMES[0] - now > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                return dest->raw = FRAME_DATA[0];
            }
        }
            
        /** Sets data in pointer to MS_212
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_212(uint64_t now, uint64_t max_expire_time, MS_212* dest) {
            if (LAST_FRAME_TIMES[1] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (LAST_FRAME_TIMES[1] - now > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                return dest->raw = FRAME_DATA[1];
            }
        }
            
        /** Sets data in pointer to MS_268
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_268(uint64_t now, uint64_t max_expire_time, MS_268* dest) {
            if (LAST_FRAME_TIMES[2] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (LAST_FRAME_TIMES[2] - now > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                return dest->raw = FRAME_DATA[2];
            }
        }
            
        /** Sets data in pointer to MS_2F3
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_2F3(uint64_t now, uint64_t max_expire_time, MS_2F3* dest) {
            if (LAST_FRAME_TIMES[3] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (LAST_FRAME_TIMES[3] - now > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                return dest->raw = FRAME_DATA[3];
            }
        }
            
        /** Sets data in pointer to MS_308
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_308(uint64_t now, uint64_t max_expire_time, MS_308* dest) {
            if (LAST_FRAME_TIMES[4] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (LAST_FRAME_TIMES[4] - now > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                return dest->raw = FRAME_DATA[4];
            }
        }
            
        /** Sets data in pointer to MS_312
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_312(uint64_t now, uint64_t max_expire_time, MS_312* dest) {
            if (LAST_FRAME_TIMES[5] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (LAST_FRAME_TIMES[5] - now > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                return dest->raw = FRAME_DATA[5];
            }
        }
            
        /** Sets data in pointer to AAD_580
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_AAD_580(uint64_t now, uint64_t max_expire_time, AAD_580* dest) {
            if (LAST_FRAME_TIMES[6] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (LAST_FRAME_TIMES[6] - now > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                return dest->raw = FRAME_DATA[6];
            }
        }
            
        /** Sets data in pointer to MS_608
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_MS_608(uint64_t now, uint64_t max_expire_time, MS_608* dest) {
            if (LAST_FRAME_TIMES[7] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (LAST_FRAME_TIMES[7] - now > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                return dest->raw = FRAME_DATA[7];
            }
        }
            
	private:
		uint64_t FRAME_DATA[8];
		uint64_t LAST_FRAME_TIMES[8];
};
#endif // __ECU_MS_H_