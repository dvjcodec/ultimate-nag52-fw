
# Remember those text files from my MercedesUI project?
# Well this script converts the data from those files
# into unions that can be manipulated in C++!

import sys
import os

file_name = sys.argv[1]
frame_name = sys.argv[2]

lines = open(file_name, 'r').readlines()


def clear_bit(mask, bit):
    return mask & ~(1<<bit)

def get_data_type(len: int) -> str:
    if len == 1:
        return "bool"
    elif len <= 8:
        return "uint8_t"
    elif len <= 16:
        return "short"
    elif len <= 32:
        return "int"
    else:
        raise "> 64bit numbers not handled!"


#print("{0:{fill}64b}".format(mask, fill = '0'))

def get_param_text(name: str, desc: str, offset: int, length: int, is_enum: bool) -> str:
    # assume all CAN Frames are 64bits in size, and use BigEndian (All MB ECUs in W203 do!)

    if 64-offset-length < 0:
        raise "Shift is less than 0!?"

    mask = 0xFFFFFFFFFFFFFFFF

    start_mask = 63-offset
    for bit in range(0,length):
        mask = clear_bit(mask, start_mask-bit)

    f_mask = 0x0
    for bit in range(0,length):
        f_mask = (f_mask | 0x01 << bit)

    if is_enum == True: # Enum parsing
        enum_name = "{}_{}".format(frame_name.upper(), name)
        string = ""
        string =  "    // Sets {}\n".format(desc)
        string += "    void set_{}({} value){{ raw = (raw & 0x{:{fill}16x}) | ((uint64_t)value & 0x{:x}) << {}; }}\n".format(enum_name, get_data_type(length), mask, f_mask, 64-length-offset, fill='0')
        string += "    // Gets {}\n".format(desc)
        string += "    {} get_{}() {{ return ({})(raw >> {} & 0x{:x}); }}\n".format(enum_name, name, enum_name, 64-length-offset, f_mask)
    else: # Normal integer / Boolean
        string = ""
        string =  "    // Sets {}\n".format(desc)
        string += "    void set_{}({} value){{ raw = (raw & 0x{:{fill}16x}) | ((uint64_t)value & 0x{:x}) << {}; }}\n".format(name, get_data_type(length), mask, f_mask, 64-length-offset, fill='0')
        string += "    // Gets {}\n".format(desc)
        string += "    {} get_{}() {{ return raw >> {} & 0x{:x}; }}\n".format(get_data_type(length), name, 64-length-offset, f_mask)
    return string


frame_lines = []

entries = []

enum_entries_unfiltered = []

enum_entries = {}

located_frame = False
in_enum = False
frame_id = ""
for line in lines:
    if line.strip().startswith("FRAME"):
        if line.strip().startswith("FRAME {}".format(frame_name)):
            frame_id = line.split("(")[1].split(")")[0]
            located_frame = True
        elif located_frame: # next frame located, we are done loading lines!
            break
    elif located_frame and not line.strip().startswith("RAW:"):
        # ONLY ADD ENTRIES - NOT ENUM VALUES
        entries.append(line.strip())
    elif located_frame and line.strip().startswith("RAW:"):
        try:
            enum_entries_unfiltered.append((entries[-1].split(": ")[1].split(",")[0],line.strip()))
        except Exception:
            print(entries[-1])
            enum_entries_unfiltered.append((entries[-1],line.strip()))
            continue

if located_frame == False:
    raise Exception("Frame not found!")

for x in enum_entries_unfiltered:
    if x[0] in enum_entries:
        enum_entries[x[0]].append(x[1])
    else:
        enum_entries[x[0]] = [x[1]]


ecu_name = frame_name.rstrip('h').split("_")[0]

print(enum_entries)

res = ""
print("Found {} entries for {}".format(len(entries), frame_name))

res += "#ifndef {}_H_\n".format(frame_name.upper())
res += "#define {}_H_\n\n".format(frame_name.upper())
res += "/**\n"
res += " * AUTOGENERATED BY gen_unions.py\n"
res += "*/\n"
res += "#include <stdint.h>\n"
res += "\n"
res += "#define {}_ID {}\n".format(frame_name.rstrip('h'), frame_id)
res += "\n\n\n"

# Enums for CAN frame
for x in enum_entries:
    res += "enum class {}_{} {{\n".format(frame_name.upper(), x)

    for enum in enum_entries[x]:
        raw = enum.split("RAW: ")[1].split(" -")[0]
        name = enum.split(" / ")[-1]
        desc = enum.split(" - ")[1].split(" / ")[0]
        res += "    {} = {}, /** {} */\n".format(name, raw, desc)


    res += "};\n\n"


res += "\n\n\n"
res += "typedef union {\n"
res += "    uint8_t bytes[8];\n"
res += "    uint64_t raw;\n\n"

for entry in entries:
    if not entry:
        continue
    name = entry.split(": ")[1].split(",")[0]
    offset = int(entry.split("OFFSET ")[1].split(" LEN")[0])
    length = int(entry.split("LEN ")[1].split(" ")[0])
    desc = entry.split(" - ")[1]

    is_enum =  name in enum_entries

    res += get_param_text(name, desc, offset, length, is_enum)
    res += "\n"

# Export frame function

res += "    /** Imports the frame data from a source */\n"
res += "    void import_frame(uint32_t cid, uint8_t* data, uint8_t len) {\n"
res += "        if (cid == {}_ID) {{\n".format(frame_name.rstrip('h'))
res += "            for (int i = 0; i < len; i++) {\n"
res += "                bytes[7-i] = data[i];\n"
res += "            }\n"
res += "        }\n"
res += "    }\n"
res +="\n"
res += "    /** Exports the frame data to a destination */\n"
res += "    void export_frame(uint32_t* cid, uint8_t* data, uint8_t* len) {\n"
res += "        *cid = {}_ID;\n".format(frame_name.rstrip('h'))
res += "        *len = 8;\n"
res += "        for (int i = 0; i < *len; i++) {\n"
res += "            data[i] = bytes[7-i];\n"
res += "        }\n"
res += "    }\n"
res += "}} {};\n".format(frame_name.rstrip('h'))
res += "\n#endif\n"




path = "src/{}/".format(ecu_name)
if not os.path.exists(path):
    os.makedirs(path)

write_file = open("src/{}/{}.h".format(ecu_name, frame_name.rstrip('h')), 'w')
write_file.write(res)
print("Parse complete")
